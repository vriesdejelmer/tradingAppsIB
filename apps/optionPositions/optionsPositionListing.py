# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optionsGraph.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtCore import Qt, QSize
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPalette, QColor
from PyQt5.QtWidgets import * #QMainWindow, QCompleter, QTableWidgetItem, QTabBar, QStylePainter, QStyleOptionTab
import numpy as np
from dataComps.Constants import Constants, OrderType
from dataComps.DataStructures import DetailObject
from .OptionPositionWindow import OptionPositionWindow
from uiComps.customWidgets.OptionTabWidget import OptionTabWidget, SpecOptionTabWidget
import sys
import threading
import pandas as pd

from dataComps.PositionDataManagement import PositionDataManager
from dataComps.UserDataManagement import fetchPositionNotes, writePositionNotes
from uiComps.QHelper import SymbolCompleter

class OptionPositions(OptionPositionWindow):

    currentTab = None
    postion_manager = None

    def __init__(self, ib_interface=None):
        super().__init__()

        self.setup()
        
        self.notes = fetchPositionNotes()
        
        if ib_interface is not None:
            self.postion_manager = PositionDataManager(self.dataUpdate, ib_interface)
        else:
            self.statusBar.showMessage('Offline')        
        
    def setup(self):
        self.myTabBar = MyTabBar(self.tabWidget.tabBar())
        self.tabWidget.setTabBar(self.myTabBar) 
        self.tabWidget.currentChanged.connect(self.tabSelection)
        self.createMainTab()


    def createMainTab(self):

        self.main_tab = OptionTabWidget()
        self.tabWidget.addTab(self.main_tab, "All")
        self.main_tab.tab_name = "All"

    
    def tabSelection(self, index):
        if index > 0:
            self.currentTab = self.tabWidget.currentWidget()
        else:
            self.currentTab = None

        if self.postion_manager is not None:
            selected_instr = self.tabWidget.tabText(index)
            positions = self.postion_manager.getOptionPositions()
            self.postion_manager.requestMarketData(DetailObject(symbol=selected_instr))
        

    def dataUpdate(self, signal):
        if signal == Constants.POSITIONS_RETRIEVED:
            self.processData()
        elif signal == Constants.UNDERLYING_PRICE_UPDATE:
            if self.currentTab is not None:
                self.currentTab.setPrice(self.postion_manager.price)
        elif signal == Constants.CONTRACT_DETAILS_FINISHED:
            while self.postion_manager.hasNewItem():
                item = self.postion_manager.getLatestItem()
                

    def createRectPixmap(self, col=QtGui.QColor(240,50,50)):
        px = QtGui.QPixmap(50,32)
        px.fill(QtCore.Qt.transparent)
        pxSize = px.rect().adjusted(1,1,-1,-1)
        painter = QtGui.QPainter(px)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setBrush(col)
        painter.setPen(QtGui.QPen(QtGui.QColor(150,20,20), 1.25))
        painter.drawRect(pxSize)
        painter.end()
        return px


    def notesUpdate(self, signal):
        tab_index = self.findIndexForSymbol(signal)
        tab = self.tabWidget.widget(tab_index)
        new_text = tab.notes_window.toPlainText()
        self.notes[signal] = new_text
        writePositionNotes(self.notes)


    def processData(self):

        positions = self.postion_manager.getOptionPositions()   
        self.main_tab.setData(positions)

        for instrument in positions['INSTRUMENT'].unique():
            self.addTab(instrument, positions[(positions["INSTRUMENT"] == instrument)])

        self.postion_manager.stopPositionRequest()

        self.setNotes()
        self.myTabBar.update()


    def setNotes(self):
        for symbol, note in self.notes.items():
            tab_index = self.findIndexForSymbol(symbol)
            if tab_index >= 0:
                self.tabWidget.widget(tab_index).notes_window.setPlainText(note)

    def orderExpiration(self):
        tab_count = self.tabWidget.count()

        exp_list = np.empty((tab_count), dtype=int)
        exp_list[0] = -1   # we set the "All" tab to -1 one so that it automatically comes first
        for tab_index in range(1, tab_count):
            days_till = self.tabWidget.widget(tab_index).days_to_expiration
            exp_list[tab_index] = (days_till)

        sorted_exp = np.argsort(exp_list)

        sorted_names = list(map(self.tabWidget.tabText, sorted_exp))
        
        for sorted_name in reversed(sorted_names):
            symbol_index = self.findIndexForSymbol(sorted_name)
            self.myTabBar.moveTab(symbol_index, 0)


    def orderValue(self):
        tab_count = self.tabWidget.count()

        value_list = np.empty((tab_count), dtype=float)
        value_list[0] = -1   # we set the "All" tab to -1 one so that it automatically comes first
        for tab_index in range(1, tab_count):
            value_list[tab_index] = abs(self.tabWidget.widget(tab_index).total_value)

        sorted_value = np.argsort(value_list)

        sorted_names = list(map(self.tabWidget.tabText, sorted_value))
        # logger.printLine(sorted_names)
        # logger.printLine(type(sorted_names))
        
        for sorted_name in reversed(sorted_names):
            symbol_index = self.findIndexForSymbol(sorted_name)
            self.myTabBar.moveTab(symbol_index, 0)


    def findIndexForSymbol(self, symbol):
        print("We search for: ", symbol, ", ", self.tabWidget.count())
        for index in range(self.tabWidget.count()):
            if self.tabWidget.tabText(index) == symbol:
                return index

        return -1


    def addTab(self, name, positions):
        instrument_tab = SpecOptionTabWidget()
        self.tabWidget.addTab(instrument_tab, name)
        instrument_tab.setData(positions)
        instrument_tab.tab_name = name
        instrument_tab.text_updater.connect(self.notesUpdate)



    def fetchPositions(self):
        self.postion_manager.retrievePositions()



class TabBarStyle(QtWidgets.QProxyStyle):


    def drawControl(self, element, option, painter, widget=None):
        icon = QtGui.QIcon()

        #logger.printLine("How far do we get?")
        
        if element == QtWidgets.QStyle.CE_TabBarTabLabel:
            icon = QtGui.QIcon(option.icon)
            # draw without icon
            option.icon = QtGui.QIcon()

        super(TabBarStyle, self).drawControl(element, option, painter, widget)

        if icon.isNull():
            return

        alignment = QtCore.Qt.AlignCenter | QtCore.Qt.TextShowMnemonic

        if not self.proxy().styleHint(QtWidgets.QStyle.SH_UnderlineShortcut, option, widget):
            alignment |= QtCore.Qt.TextHideMnemonic


        tab_rect = self.proxy().subElementRect(QtWidgets.QStyle.SE_TabBarTabText, option, widget)

        fm = QtGui.QFontMetrics(painter.font())
        iconRect = fm.boundingRect(option.text)
        iconSize = QtCore.QSize(option.iconSize)

        if not iconSize.isValid():
            iconExtent = self.proxy().pixelMetric(QtWidgets.QStyle.PM_SmallIconSize)
            iconSize = QtCore.QSize(iconExtent, iconExtent)
            tabIconSize = icon.actualSize(
                iconSize,
                QtGui.QIcon.Normal
                if (option.state & QtWidgets.QStyle.State_Enabled)
                else QtGui.QIcon.Disabled,
                QtGui.QIcon.On
                if (option.state & QtWidgets.QStyle.State_Selected)
                else QtGui.QIcon.Off,
            )
            # High-dpi icons do not need adjustment; make sure tabIconSize is not larger than iconSize
            iconSize = QtCore.QSize(
                min(tabIconSize.width(), iconSize.width()),
                min(tabIconSize.height(), iconSize.height()),
            )
        
        offset = 0
        
        tabIcon = icon.pixmap(
            widget.window().windowHandle() if widget else None,
            QSize(100,20),
            QtGui.QIcon.Normal
            if (option.state & QtWidgets.QStyle.State_Enabled)
            else QtGui.QIcon.Disabled,
            QtGui.QIcon.On
            if (option.state & QtWidgets.QStyle.State_Selected)
            else QtGui.QIcon.Off,
        )

        painter.drawPixmap(tab_rect.x()+10, tab_rect.y(), tabIcon)
        rect = option.rect.moveCenter(-50,0)
        painter.drawText(rect, QtCore.Qt.AlignCenter, option.text)

    def createRectPixmap(self, col=QtGui.QColor(240,50,50)):
        px = QtGui.QPixmap(40,20)
        px.fill(QtCore.Qt.transparent)
        pxSize = px.rect().adjusted(1,1,-1,-1)
        painter = QtGui.QPainter(px)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setBrush(col)
        painter.setPen(QtGui.QPen(QtGui.QColor(150,20,20), 1.25))
        painter.drawRect(pxSize)
        painter.end()
        return px

class MyTabBar(QTabBar):

    __coloredTabs = [0, 1,2,3]

    def paintEvent(self, event):
        #super().paintEvent(event)
        painter = QStylePainter(self)
        opt = QStyleOptionTab()

        for i in range(self.count()):
            self.initStyleOption(opt, i)
            if i in self.__coloredTabs:
                opt.palette.setColor(QPalette.Button, QColor("#ff9900"))

            painter.drawControl(QStyle.CE_TabBarTabShape, opt)
            painter.drawControl(QStyle.CE_TabBarTabLabel, opt)


if __name__ == "__main__":

    app = QtWidgets.QApplication(sys.argv)
    QtWidgets.QApplication.setStyle(QStyleFactory.create('Fusion'))
    app.aboutToQuit.connect(app.deleteLater)
    window = OptionPositions()
    window.show()
    app.exec_()



